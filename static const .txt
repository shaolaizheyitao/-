static 
	1、修饰局部变量
	此时，它被叫做 静态局部变量 ，该变量会被存储在进程的全局数据区。
	即使它声明时没有初始化，编译器也会默认的给它初始化为0.
	由于它存在于全局数据区，所以函数结束之后它并不会被释放掉
	它的值在下一次的函数调用中仍会保留
	但是它的作用域也仅在该定义的函数中


	（普通局部变量），它存在于函数的内部，编译器默认不对这个变量进行初始化，
	也就是说每次这个变量的初始化的值都是不确定的，除非我们主动对它进行显示初始化
	每次函数运行结束之后，它就会被马上释放掉

	2、修饰全局变量
	此时，它被叫做 静态全局变量 ，该变量会被存储在进程的全局数据区，
	同上，即使它声明时没有初始化，编译器也会默认的给它初始化为0.
	此外，这个静态全局变量仅在此文件有效，其他文件不可访问，
	但是其他文件可以定义与它同名的变量，两者没有任何关联。
	
	（普通的全局变量），它对整个工程所见，
	其他的文件可以使用extern关键字来声明这个全局变量，然后来对它进行使用

	3、修饰函数
	此时，它被叫做 静态函数 ，该函数仅在此文件有效，其余文件不能够调用
	这个静态函数，其他文件可以定义与它同名的函数，两者也没有相互联系.


	综上所述，static包含三种用法
	函数内部static变量
	函数外部static变量
	static函数
	
	
	
	
	
const
		作用就是将变量常量化 ，它引入了常量的变化，让我们
			不要去修改不该修改的内容，同时让更多的错误在编译时被发现

		const修饰的变量能不能被修改 取决于它的环境
		在某些单片机环境下，const修饰的变量是不能够
		被修改的
		
		但是在gcc的环境下，const是通过编译器在编译时执行检查来确保实现的
		也就是说const不能修改是编译时出错，而不是运行时出错
		所以只要我们想办法骗过编译器就能够修改const修饰的变量
		以下是一个例子
		const in a = 20;
		int *p = &a;
		*p = 19;
		此时我们可以通过*p来对a这个const修饰的变量进行修改
		但是这样编译器会报警告
		当我们将 int *p = &a; 修改为 int *p = (int *)&a;
		此时警告会被消除。即对 &a进行强制类型转换
	
		const修饰指针
			例如：	const int * p   
			此时，const修饰的是p这个指针指向的内容
			即*p不可以被作为左值而被重新赋值，如 *p =50 就是错误的
			而p这个指针可以指向其他地方，如 p = &b
			
			而      int * const p
			表示此时 const 修饰的是p这个指针
			即 *p可以被作为左值而被重新赋值，如 *p = 30
			而p这个指针不能被指向其他地方,如 p = &b就是错误的
		
		此外还有 const int * const p 这种类型
		此时 p所指向的内容和p这个指针都不能被更改
		
		因此，const一般用于修饰函数中只读的参数，以防止调用函数者的误操作
		
		