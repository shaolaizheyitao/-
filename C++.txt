cbegin  cend

difference_type

end()函数返回的是最后一个元素后的位置，而不是最后一个元素

如果不清楚元素的确切个数，请使用vector 而非数组

constexpr常量表达式

定义数组不允许auto

不存在引用数组，但是可以存在引用一个数组，即数组的引用
两个指针相减的结果的类型是一种名为ptrdiff_t，他是一种带符号的类型

可以用数组来初始化vector对象  用法：vector<int> arr(begin(int_arr),end(int_arr))

const变量的初始化可以延迟到运行时，而constexpr变量必须在编译时
进行初始化，所有的constexpr对象都是const的，但是不一定所有的const对象都是constexpr

参与取余的对象必须是整数类型

对一个可能非常大的对象进行操作的话，尽量使用引用类型，避免对他进行拷贝

尽量使用递增递减的前置版本，因为后置版本在运算的过程中需要保留一份副本作为返回

*pbeg++    返回的是未加加的副本

关于符号位如何处理没有明确的规定，所以强烈建议晋江位运算符作用于无符号类型

移位运算符的优先级不高不低，介于中间：比算术运算符低，但是比赋值运算符，关系运算符，条件运算符高

sizeof一个函数  例如 sizeof fun()  返回的是这个函数的返回值类型的大小

static_cast<double*>(p)

const_case

case关键字和它对应的值一起被称为case标签。case标签必须是  整型常量表达式

任何两个case的标签的值不能相同

C++程序行使比较自由，所以case标签之后不一定非得换行，把几个case标签写在一行里，强调这些case代表的是某个范围内的值

定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程

ctrol + z 结束windows下的文件输入

如果需要对范围for语句的序列元素进行写操作，循环变量必须声明成引用类型

do while 语句应该在括号包围起来的条件后面用一个分好表示语句

熟悉C的程序员常常使用指针类型的形参访问函数外部的对象，在C++中，建议使用引用类型的形参替代指针

如果函数无须改变引用形参的值，最好将其声明为常量引用

不能用一个字面值初始化一个非常量引用

initializer_list  它的对象的值是常量值，无法被改变

如果想向initializer_list形参中传递一个值得序列，则必须把序列放在一対花括号内

省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在床底给省略符形参时都无法正确拷贝

调用一个返回引用的函数得到左值，其他返回类型的到右值。

（*func(int i ))[10] 表示解引用func的调用将得到一个大小是10的数组 

尾置返回类型    任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，
				比如返回类型是数组的指针或者数组的引用。
				尾置返回类型跟在形参列表后面并以一个->符号开头
				func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
				auto func(int i)-> int (*) [10]

decltype(odd) *arrPtr(int i)  返回一个指针，该指针指向含有5个整数的数组
		arrPtr使用关键字decltype 表示他的返回值是个指针，并且该指针所指的对象与odd的类型一致
		decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是一个数组
		
main函数不能重载	

不允许两个函数出了返回类型外其他所有的要素都相同。假设有两个函数，他们的形参数量和类型都是一样的但是返回类型不同，则第二个函数的声明是错误的

一个拥有顶层 const的形参无法 与 另一个没有顶层const的形参区分开来
另一方面，如果形参时某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数的重载，此时的const是底层的
但是，当我们传递一个费常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数

函数匹配是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫作重载确定

在C++语言中名字的查找发生在检查类型之前

当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面

多次声明一个函数是合法的，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

string screen(sz,sz,char = ' ');  //此时前面两个没有默认值
string screen(sz,sz,char = '*');  //我们不能修改一个存在的默认值
string screen(sz = 24 ,sz = 80,char);  //我们可以按照如下形式添加默认值			
				
constexpr 函数   是指能用于常量表达式的函数  定义constexpr函数有几项约定
					函数的返回值类型及所有形参的类型都得是字面值类型，而且函数体中必须有且仅有一条return语句
执行初始化任务时，编译器把对constexpr函数的调用替换成起结果值。为了能够在编译过程中随时展开，constexpr函数被隐式的指定为内联函数

constexpr函数不一定返回常量表达式

assert是一种预处理宏，所谓预处理宏其实是一个预处理变量，
	assert（expr） 首先对expr求值，如果表达式为假，assert输出信息并终止程序的执行如果为真就什么都不做
	
NDEBUG预处理变量
		assert的行为依赖于一个名为NDEBUG的预处理变量的状态，如果定义了NDEBUG，则assert无效

nullptr  C++语言中定义的空指针

指针类型必须与重载函数中的某一个精确匹配

定义在类内部的函数是隐式的inline函数

常量对象、常量对象的引用和指针都只能调用它的常量成员函数

如果成员函数被声明成常量成员函数，那么他的定义也必须在参数列表后面明确指定const属性。
	同时，类外部定义的成员的名字必须包含他所述的类名
	
一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内是
	非成员函数是区别于成员函数的，即它不是任何一个类中的成员函数，
	假如在类中需要用到这个非成员函数，那么他的声明应该与类在同一个文件内
	
只有当类没有声明任何构造函数时，编译器才会自动的生成默认构造函数

没有出现在构造函数初始值列表中的成员将通过响应的类内初始值（如果存在的话）初始化
	，或者执行默认初始化。

使用class和struct定义类唯一的区别就是默认的访问权限

类可以允许其他类或者函数访问它的飞公有成员，方法是令其他类或者函数成为它的友元（friend）。
	如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句

友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。
	友元不是类的成员也不受他所在的区域访问控制级别的约束。
		一般来说，最好在类定义开始或结束前的位置集中声明友元
		
因为我们已经提供了一个构造函数，所以编译器将不会自动生成默认的构造函数。
	如果我们的类需要默认构造函数，必须显式地把它声明出来。我们使用 = default告诉编译器为我们合成默认的构造函数
	
可变数据成员（mutable data member）永远不会是const，即使它是const对象的成员。
		因此，一个xonst成员函数可以改变一个可变成员的值。
		
类允许包含指向他自身类型的引用或指针

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员

每个类负责控制自己的友元类和友元函数，友元关系不能传递

尽管重载函数的名字相同，但他们仍然是不同的函数，因此，如果一个类想把一组重载函数声明成它的友元，他需要对这组函数中的每一个分别声明

友元声明的作用是影响访问权限，他本身并非普通意义上的说明

类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后

尽管类的成员被隐藏了，但我们仍然可以通过加上类的名字或显示的使用this指针来强制访问成员

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域的声明，还需要再成员函数定义之前的全局作用域中的声明

如果成员是const或者引用，或者属于某种类类型且该类型没有定义默认构造函数时，我们必须通过初始值列表为这些成员提供初始值

在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值
除了效率问题外更重要的是，一些数据成员必须被初始化。建议读者养成使用构造函数初始值的习惯，这样能
避免某些意想不到的编译出错，特别是遇到有的类含有需要构造函数初始值的成员时。

构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序，成员的初始化顺序与他们在类定义中的出现顺序一致

一般来说，初始化的顺序没什么特别要求。不过如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了

最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员

如果一个构造函数为所有的参数都提供了默认实参，则它实际上也定义了默认构造函数

委托构造函数

能通过一个实参调用的构造函数定义了一条从构造函数的参数类型像类类型饮食转换的规则

抑制构造函数定义的隐式转换
	关键字explicit 只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，
			所以无需将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复
			
我们通过在成员的声明之前加上关键字static使其与类关联在一起。和其他成员一样，
静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型			
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。
类似的，静态成员函数也不与任何对象绑定在一起，他们不包含this指针。
作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。

虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员：
static关键字只出现在类内部的声明语句中。

因为静态数据成员不属于类的任何一个对象，所以他们并不是在创建类的对象时被定义的。
这意味着他们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化
静态成员。相反，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次

类似于全局变量。静态数据成员定义在任何函数之外。因为一旦它被定义，就将一直存在于程序的整个生命周期中

通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，
不过要求静态成员必须是字面值常量类型的constexpt。
例如  ： static constexpr int rate = 30；

静态成员可以是不完全类型    然后还有一个   静态成员可以作为默认实参    

由于不能拷贝io对象，因此我们也不能将形参或返回类型设置为流类型。
进行io操作的函数通常以引用方式传递和返回流。读写一个io对象会改变其状态，因此传递和返回的引用设置为const

一个流一旦发生错误，其上后续的io操作都会失败。只有当一个流处于无错状态时，我们才可以从他读取数据，向他写入数据

while ( cin >>word)		while循环检查>>表达式返回的流的状态。如果输入操作成功，流保持有效状态，则条件为真。

查询流的状态   io库定义了4个iostate类型的constexpr值表示特定的位模式
	badbit，系统级不可恢复的读写错误		failbit被置位  这种问题可以修正，流可以继续使用
	eofbit  到达文件结束位置 ，此时failbit也会被置位     goodbit 它的值为0，表示流未发生错误
如果badbit、failbit、eofbit任意一个标志被置位，那么检测流状态的条件会失败

实际上，我们将流当做条件使用的代码就等价于！fail()。而eof和bad操作只能表示特定的错误。

流对象的rdstate成员返回一个iostate的值，对应当前流的状态。
setstate操作将给定条件置位，表示发生了对应错误。clear不接受参数的版本清除（复位）所有的错误标志位

cin.clear(cin.rdstate() & ~cin.failbit &~cin.badbit);
复位failbit和badbit，保持其他标志位不变

1、我们可以使用操作符如endl来显式刷新缓冲区
2、在每个输出操作之后，我们可以用操纵符unitbit设置流的内部状态，来清空缓冲区，默认情况下，
对cerr是设置unitbit的，因此写到cerr的内容都是立即刷新的。
3、一个输出流可能被关联到另一个流。。例如默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新

endl 	完成换行并刷新缓冲区
flush 	刷新缓冲区，但不输出额外的任何字符
ends   向缓冲区插入一个空字符，然后刷新缓冲区

cout << unitbuf	//所有输出操作后都会立即刷新缓冲区
cout << nountbit//回到正常的缓冲方式

如果程序异常终止，输出缓冲区是不会被刷新的。所有当程序崩溃时，我们要确认哪些你认为已经输出的数据缺失已经刷新了

tie   每个流同时最多关联到一个流，但是多个流可以同时关联到一个输出流

ifstream 从一个给定文件读取数据   ofstream向一个给定文件写入数据  fstream可读写给定文件

如果有一个函数接受一个ostream& 参数，我们在调用这个函数时，可传递给他一个ofstream对象，对istream&和ifstream也是类似的

当一个fstream 对象呗销毁时，close会被自动调用

如果你提示不允许使用不完整类型时，要注意包含头文件

调用open打开文件   还有一种是用一个文件名初始化流来打开文件

保留被ofstream打开的文件中已有数据的唯一方法是显式指定app或in模式。

文件模式  
	in 以读的方式打开     out  以写的方式打开    app  每次写操作前均定位到文件末尾
	ate 打开文件后立即定位到文件末尾	trunc	截断文件   binary  以二进制方式进行IO
	
string流
		istringstream  从string读取数据		ostringstream  向string写入数据
			stringstream    既可以从string读数据 ，也可以从string 写数据
						
iostream处理控制台		fstream处理命名文件		stringstream完成内存string的IO

顺序容器类型
	vector	deque	list	forword_list	array	string

通常，使用vector是最好的选择，除非你有很好的理由选择其他容器

一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。
容器均定义为模板类   我们必须提供额外信息来生成特定的容器类型
	list<Sales_data>	   deque<double>

size_type   由string类类型和vector类类型定义的类型，用以保存任意string对象或vector对象的长度
	标准库类型将size_type定义为unsigned类型
	
将一个容器初始化为另一个容器的拷贝有两种方法：可以直接拷贝整个容器，或者（array除外）拷贝由另一个迭代器对指定的元素范围

当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。

只有顺序容器的构造函数才接受大小参数，关联容器并不支持

当定义一个array时，除了之指定元素类型，还要指定容器大小
	array<init,42>	数组类型包括元素类型和大小
虽然我们不能对内置数组类型进行拷贝或者对象赋值操作，但是array容器并没有这种限制
array<int,5> digits = {0,1,2,3,4}    array<int,5> copy = digits

赋值相关的运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap 操作将容器内容交换不会导致
指向容器的迭代器、引用和指针失效。

list<string> names;  vector<const char *> oldstyle;    names.assign(oldstyle.cbegin(),oldstyle.cend())
由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器

assign的第二个版本接受一个整型值和一个元素值，他用指定书目且具有相同给定值得元素替换容器中原有的元素
	list<string> ls(1)  //1个元素，为空string    
	ls.assign(10,"ha")  //10个元素，每个都是“ha”
	
swap
		调用swap后，两个容器本身的元素并未交换，swap只是交换了两个容器的内部数据结构
	除了array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成
	
元素不会被移动的事实意味着，除了 string  外，指向容器的迭代器、引用和指针在swap操作之后都不会失效

但是与其他容器不同，swap两个array会真正交换他们额元素

非成员版本的swap在泛型编程中是非常重要的，统一使用非成员版本的swap是一个好习惯

容器大小操作        
	成员函数 size 返回容器中元素的数目； empty 当size为0时返回bool值true，否则返回flase；
	max_size	返回一个大于或等于该类型容器所能容纳的最大元素数的值

容器的关系运算符
	只有当其他元素类型也定义了相应的比较运算符时，我们才可以使用关系运行算符来比较两个容器
	
向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效

包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数。
	这两个操作分别返回首元素和尾元素的引用。

在容器中访问元素的成员函数（即，front、back、下标、at）返回的都是引用。如果容器一个const对象，
则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以改变元素的值

删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它们是存在的

删除多个元素
	elem1 = slist.erase(elem1,elem2); 
	迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置

如果在一个循环中插入、删除deque、string或vector中的元素，不要缓存end返回的迭代器。

reserve并不改变容器中元素的数量，他仅影响vector预先分配多大的内存空间

容器的size是指它已经保存的元素的数目；而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素





















