cbegin  cend

difference_type

end()函数返回的是最后一个元素后的位置，而不是最后一个元素

如果不清楚元素的确切个数，请使用vector 而非数组

constexpr常量表达式

定义数组不允许auto

不存在引用数组，但是可以存在引用一个数组，即数组的引用
两个指针相减的结果的类型是一种名为ptrdiff_t，他是一种带符号的类型

可以用数组来初始化vector对象  用法：vector<int> arr(begin(int_arr),end(int_arr))

const变量的初始化可以延迟到运行时，而constexpr变量必须在编译时
进行初始化，所有的constexpr对象都是const的，但是不一定所有的const对象都是constexpr

参与取余的对象必须是整数类型

对一个可能非常大的对象进行操作的话，尽量使用引用类型，避免对他进行拷贝

尽量使用递增递减的前置版本，因为后置版本在运算的过程中需要保留一份副本作为返回

*pbeg++    返回的是未加加的副本

关于符号位如何处理没有明确的规定，所以强烈建议晋江位运算符作用于无符号类型

移位运算符的优先级不高不低，介于中间：比算术运算符低，但是比赋值运算符，关系运算符，条件运算符高

sizeof一个函数  例如 sizeof fun()  返回的是这个函数的返回值类型的大小

static_cast<double*>(p)

const_case

case关键字和它对应的值一起被称为case标签。case标签必须是  整型常量表达式

任何两个case的标签的值不能相同

C++程序行使比较自由，所以case标签之后不一定非得换行，把几个case标签写在一行里，强调这些case代表的是某个范围内的值

定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程

ctrol + z 结束windows下的文件输入

如果需要对范围for语句的序列元素进行写操作，循环变量必须声明成引用类型

do while 语句应该在括号包围起来的条件后面用一个分好表示语句

熟悉C的程序员常常使用指针类型的形参访问函数外部的对象，在C++中，建议使用引用类型的形参替代指针

如果函数无须改变引用形参的值，最好将其声明为常量引用

不能用一个字面值初始化一个非常量引用

initializer_list  它的对象的值是常量值，无法被改变

如果想向initializer_list形参中传递一个值得序列，则必须把序列放在一対花括号内

省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在床底给省略符形参时都无法正确拷贝

调用一个返回引用的函数得到左值，其他返回类型的到右值。

（*func(int i ))[10] 表示解引用func的调用将得到一个大小是10的数组 

尾置返回类型    任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，
				比如返回类型是数组的指针或者数组的引用。
				尾置返回类型跟在形参列表后面并以一个->符号开头
				func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
				auto func(int i)-> int (*) [10]

decltype(odd) *arrPtr(int i)  返回一个指针，该指针指向含有5个整数的数组
		arrPtr使用关键字decltype 表示他的返回值是个指针，并且该指针所指的对象与odd的类型一致
		decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是一个数组
		
main函数不能重载	

不允许两个函数出了返回类型外其他所有的要素都相同。假设有两个函数，他们的形参数量和类型都是一样的但是返回类型不同，则第二个函数的声明是错误的

一个拥有顶层 const的形参无法 与 另一个没有顶层const的形参区分开来
另一方面，如果形参时某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数的重载，此时的const是底层的
但是，当我们传递一个费常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数

函数匹配是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫作重载确定

在C++语言中名字的查找发生在检查类型之前

当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面

多次声明一个函数是合法的，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

string screen(sz,sz,char = ' ');  //此时前面两个没有默认值
string screen(sz,sz,char = '*');  //我们不能修改一个存在的默认值
string screen(sz = 24 ,sz = 80,char);  //我们可以按照如下形式添加默认值			
				
constexpr 函数   是指能用于常量表达式的函数  定义constexpr函数有几项约定
					函数的返回值类型及所有形参的类型都得是字面值类型，而且函数体中必须有且仅有一条return语句
执行初始化任务时，编译器把对constexpr函数的调用替换成起结果值。为了能够在编译过程中随时展开，constexpr函数被隐式的指定为内联函数

constexpr函数不一定返回常量表达式

assert是一种预处理宏，所谓预处理宏其实是一个预处理变量，
	assert（expr） 首先对expr求值，如果表达式为假，assert输出信息并终止程序的执行如果为真就什么都不做
	
NDEBUG预处理变量
		assert的行为依赖于一个名为NDEBUG的预处理变量的状态，如果定义了NDEBUG，则assert无效

nullptr  C++语言中定义的空指针

指针类型必须与重载函数中的某一个精确匹配

定义在类内部的函数是隐式的inline函数

常量对象、常量对象的引用和指针都只能调用它的常量成员函数

如果成员函数被声明成常量成员函数，那么他的定义也必须在参数列表后面明确指定const属性。
	同时，类外部定义的成员的名字必须包含他所述的类名
	
一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内是
	非成员函数是区别于成员函数的，即它不是任何一个类中的成员函数，
	假如在类中需要用到这个非成员函数，那么他的声明应该与类在同一个文件内
	
只有当类没有声明任何构造函数时，编译器才会自动的生成默认构造函数

没有出现在构造函数初始值列表中的成员将通过响应的类内初始值（如果存在的话）初始化
	，或者执行默认初始化。

使用class和struct定义类唯一的区别就是默认的访问权限

类可以允许其他类或者函数访问它的飞公有成员，方法是令其他类或者函数成为它的友元（friend）。
	如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句

友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。
	友元不是类的成员也不受他所在的区域访问控制级别的约束。
		一般来说，最好在类定义开始或结束前的位置集中声明友元
		
因为我们已经提供了一个构造函数，所以编译器将不会自动生成默认的构造函数。
	如果我们的类需要默认构造函数，必须显式地把它声明出来。我们使用 = default告诉编译器为我们合成默认的构造函数
	
可变数据成员（mutable data member）永远不会是const，即使它是const对象的成员。
		因此，一个xonst成员函数可以改变一个可变成员的值。
		
类允许包含指向他自身类型的引用或指针

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员

每个类负责控制自己的友元类和友元函数，友元关系不能传递

尽管重载函数的名字相同，但他们仍然是不同的函数，因此，如果一个类想把一组重载函数声明成它的友元，他需要对这组函数中的每一个分别声明

友元声明的作用是影响访问权限，他本身并非普通意义上的说明

类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后

尽管类的成员被隐藏了，但我们仍然可以通过加上类的名字或显示的使用this指针来强制访问成员

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域的声明，还需要再成员函数定义之前的全局作用域中的声明

如果成员是const或者引用，或者属于某种类类型且该类型没有定义默认构造函数时，我们必须通过初始值列表为这些成员提供初始值

在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值
除了效率问题外更重要的是，一些数据成员必须被初始化。建议读者养成使用构造函数初始值的习惯，这样能
避免某些意想不到的编译出错，特别是遇到有的类含有需要构造函数初始值的成员时。

构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序，成员的初始化顺序与他们在类定义中的出现顺序一致

一般来说，初始化的顺序没什么特别要求。不过如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了

最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员

如果一个构造函数为所有的参数都提供了默认实参，则它实际上也定义了默认构造函数

委托构造函数

能通过一个实参调用的构造函数定义了一条从构造函数的参数类型像类类型饮食转换的规则

抑制构造函数定义的隐式转换
	关键字explicit 只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，
			所以无需将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复
			
我们通过在成员的声明之前加上关键字static使其与类关联在一起。和其他成员一样，
静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型			
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。
类似的，静态成员函数也不与任何对象绑定在一起，他们不包含this指针。
作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。

虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员：
static关键字只出现在类内部的声明语句中。

因为静态数据成员不属于类的任何一个对象，所以他们并不是在创建类的对象时被定义的。
这意味着他们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化
静态成员。相反，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次

类似于全局变量。静态数据成员定义在任何函数之外。因为一旦它被定义，就将一直存在于程序的整个生命周期中

通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，
不过要求静态成员必须是字面值常量类型的constexpt。
例如  ： static constexpr int rate = 30；

静态成员可以是不完全类型    然后还有一个   静态成员可以作为默认实参    

由于不能拷贝io对象，因此我们也不能将形参或返回类型设置为流类型。
进行io操作的函数通常以引用方式传递和返回流。读写一个io对象会改变其状态，因此传递和返回的引用设置为const

一个流一旦发生错误，其上后续的io操作都会失败。只有当一个流处于无错状态时，我们才可以从他读取数据，向他写入数据

while ( cin >>word)		while循环检查>>表达式返回的流的状态。如果输入操作成功，流保持有效状态，则条件为真。

查询流的状态   io库定义了4个iostate类型的constexpr值表示特定的位模式
	badbit，系统级不可恢复的读写错误		failbit被置位  这种问题可以修正，流可以继续使用
	eofbit  到达文件结束位置 ，此时failbit也会被置位     goodbit 它的值为0，表示流未发生错误
如果badbit、failbit、eofbit任意一个标志被置位，那么检测流状态的条件会失败

实际上，我们将流当做条件使用的代码就等价于！fail()。而eof和bad操作只能表示特定的错误。

流对象的rdstate成员返回一个iostate的值，对应当前流的状态。
setstate操作将给定条件置位，表示发生了对应错误。clear不接受参数的版本清除（复位）所有的错误标志位

cin.clear(cin.rdstate() & ~cin.failbit &~cin.badbit);
复位failbit和badbit，保持其他标志位不变

1、我们可以使用操作符如endl来显式刷新缓冲区
2、在每个输出操作之后，我们可以用操纵符unitbit设置流的内部状态，来清空缓冲区，默认情况下，
对cerr是设置unitbit的，因此写到cerr的内容都是立即刷新的。
3、一个输出流可能被关联到另一个流。。例如默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新

endl 	完成换行并刷新缓冲区
flush 	刷新缓冲区，但不输出额外的任何字符
ends   向缓冲区插入一个空字符，然后刷新缓冲区

cout << unitbuf	//所有输出操作后都会立即刷新缓冲区
cout << nountbit//回到正常的缓冲方式

如果程序异常终止，输出缓冲区是不会被刷新的。所有当程序崩溃时，我们要确认哪些你认为已经输出的数据缺失已经刷新了

tie   每个流同时最多关联到一个流，但是多个流可以同时关联到一个输出流

ifstream 从一个给定文件读取数据   ofstream向一个给定文件写入数据  fstream可读写给定文件

如果有一个函数接受一个ostream& 参数，我们在调用这个函数时，可传递给他一个ofstream对象，对istream&和ifstream也是类似的

当一个fstream 对象呗销毁时，close会被自动调用

如果你提示不允许使用不完整类型时，要注意包含头文件

调用open打开文件   还有一种是用一个文件名初始化流来打开文件

保留被ofstream打开的文件中已有数据的唯一方法是显式指定app或in模式。

文件模式  
	in 以读的方式打开     out  以写的方式打开    app  每次写操作前均定位到文件末尾
	ate 打开文件后立即定位到文件末尾	trunc	截断文件   binary  以二进制方式进行IO
	
string流
		istringstream  从string读取数据		ostringstream  向string写入数据
			stringstream    既可以从string读数据 ，也可以从string 写数据
						
iostream处理控制台		fstream处理命名文件		stringstream完成内存string的IO

顺序容器类型
	vector	deque	list	forword_list	array	string

通常，使用vector是最好的选择，除非你有很好的理由选择其他容器

一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。
容器均定义为模板类   我们必须提供额外信息来生成特定的容器类型
	list<Sales_data>	   deque<double>

size_type   由string类类型和vector类类型定义的类型，用以保存任意string对象或vector对象的长度
	标准库类型将size_type定义为unsigned类型
	
将一个容器初始化为另一个容器的拷贝有两种方法：可以直接拷贝整个容器，或者（array除外）拷贝由另一个迭代器对指定的元素范围

当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。

只有顺序容器的构造函数才接受大小参数，关联容器并不支持

当定义一个array时，除了之指定元素类型，还要指定容器大小
	array<init,42>	数组类型包括元素类型和大小
虽然我们不能对内置数组类型进行拷贝或者对象赋值操作，但是array容器并没有这种限制
array<int,5> digits = {0,1,2,3,4}    array<int,5> copy = digits

赋值相关的运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap 操作将容器内容交换不会导致
指向容器的迭代器、引用和指针失效。

list<string> names;  vector<const char *> oldstyle;    names.assign(oldstyle.cbegin(),oldstyle.cend())
由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器

assign的第二个版本接受一个整型值和一个元素值，他用指定书目且具有相同给定值得元素替换容器中原有的元素
	list<string> ls(1)  //1个元素，为空string    
	ls.assign(10,"ha")  //10个元素，每个都是“ha”
	
swap
		调用swap后，两个容器本身的元素并未交换，swap只是交换了两个容器的内部数据结构
	除了array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成
	
元素不会被移动的事实意味着，除了 string  外，指向容器的迭代器、引用和指针在swap操作之后都不会失效

但是与其他容器不同，swap两个array会真正交换他们额元素

非成员版本的swap在泛型编程中是非常重要的，统一使用非成员版本的swap是一个好习惯

容器大小操作        
	成员函数 size 返回容器中元素的数目； empty 当size为0时返回bool值true，否则返回flase；
	max_size	返回一个大于或等于该类型容器所能容纳的最大元素数的值

容器的关系运算符
	只有当其他元素类型也定义了相应的比较运算符时，我们才可以使用关系运行算符来比较两个容器
	
向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效

包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数。
	这两个操作分别返回首元素和尾元素的引用。

在容器中访问元素的成员函数（即，front、back、下标、at）返回的都是引用。如果容器一个const对象，
则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以改变元素的值

删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它们是存在的

删除多个元素
	elem1 = slist.erase(elem1,elem2); 
	迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置

如果在一个循环中插入、删除deque、string或vector中的元素，不要缓存end返回的迭代器。

reserve并不改变容器中元素的数量，他仅影响vector预先分配多大的内存空间

容器的size是指它已经保存的元素的数目；而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素

容器适配器
	除了顺序容器外，标准库还定义了三个顺序容器适配器: stack\queue和priority_queue。
	适配器是标准库中的一个通用概念。容器、迭代器和函数都有适配器。

假定deq是一个deque<int>，我们可以用deq来初始化一个新的stack，如下所示
	stack<int> stk(deq);//从deq拷贝元素到stk
	
因为所有的适配器都要求容器有添加、删除、访问尾元素的能力。所以stack适配器不能构造在array、forward_list之上
	queue还不能用于vector构造。priority_queue可以构造于vector或dueue之上，但不能基于list构造。
	
stack<int> intstack  //空栈
栈默认基于deque（双向队列）实现，也可以在list或vector之上实现的。
pop		删除栈顶元素，但不返回该元素
push（item）	emplace（args）创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，或者有args构造
top（）	返回栈顶元素，但不将元素弹出栈

队列适配器
	queue默认基于deque实现      ，priority_queue默认基于vector实现
	queue也可以用list或vector实现，priority_queue也可以用deque实现

大多数算法都定义在头文件algotithm中。标准库还在头文件numeric中定义了一组数值泛型算法。

泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定；算法永远不会改变底层容器的大小。
算法可能改变容器中保存的数值，也可能在容器内移动元素，但永远都不会直接添加或删除元素。

理解算法的最基本的方法就是了解他们是否读取元素、改变元素或重排元素顺序。

accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。

对于只读而不改变元素的算法，通常最好使用cbegin（）和cend（）。
但是如果你计划使用算法返回的迭代器来改变元素的值，就需要使用begin()和end()的结果作为参数

back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。
	vector<int> vec;//空向量     auto it = back_inserter(vec);       *it = 42;//现在vec中就有一个元素，值为42

拷贝算法  copy返回的是其目的位置迭代器的值。即ret 恰好指向拷贝到a2 的尾元素之后的位置
	int a1[]={1,2,3,4}   int a2[sizeof(a1)/sizeof(*a1)];    ret = copy(begin(a1),end(a1),a2);

replace算法读入一个序列，并将其中所有等于给定值得元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列
，后两个 一个是要搜索的值，另一个是新值。他将所有等于第一个值得元素替换为第二个值：
			replace(ilist.begin(),ilist.end(),0,42);    此调用将序列中所有的0都替换为42

sort  按字典顺序排序	unique	重排输入范围，使得每个单词只出现一次 ，排列在范围的前部，返回指向不重复区域之后一个位置的迭代器
然后使用erase操作 删除重复的单词

标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。

可调用对象 ： 函数   函数指针   函数调用运算符   lambada表达式

如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。

空捕获列表表明此lambda不使用他所在函数中的任何局部变量。
一个lambda通过将局部变量包含在其捕获列表中来之处将会使用这些变量，捕获列表指引lambda在其内部包含访问局部变量所需的信息

一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。

捕获列表只用于局部飞static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字。

隐式捕获   除了显示列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lanbda体中的代码来推断我们要使用哪些变量
为了只是编译器推断捕获列表，应在捕获列表中写一个&或=。  &告诉我们的编译器采用捕获引用方式，=则表示采用值捕获方式。

当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=。此符号指定了默认捕获方式为引用或值。

如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表

当我们需要为一个lambda定义返回值类型时，必须使用尾置返回值类型   [](int i)->int {if(i<0) renturn -i;else return i;}

可以将bind函数看做一个通用的函数适配器，他接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表

反向迭代器需要递减运算符，所以不可能从一个forward_list 或一个流迭代器创建反向迭代器

迭代器的类别  输入迭代器   输出迭代器   前向迭代器  双向迭代器  随机访问迭代器   

	向输入迭代器写入数据的算法都假定目标空间足够容纳写入的数据
	
	接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大
	
	对于list和forward_list，应该优先使用成员函数版本的算法而不是通用算法。
	
	关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是 map 和 set  。
	map中的元素是一些关键字-值对：关键字起到索引的作用，值则表示与索引相关联的数据。
	set中每个元素只包含一个关键字。：set支持高效的关键字查询操作--检查一个给定的关键字是否在set中。
	
	允许重复关键字的容器的名字中都包含单词 multi          不保持关键字按顺序存储的容器的名字都以单词unordered开头
	
	因此一个unordered_multi_set是一个允许重复的，元素无序存储的集合
	一个set 没有加任何修饰词的时候 ，它 表示的是 一个 要求不重复关键字，有序存储的集合

	当初始化一个map时，必须提供关键字类型和值类型。我们将每个关键字-值对包围在花括号中： {key,value}
	
	传递给排序算法的可调用对象必须满足于关联容器中关键字一样的类型要求
	
	我们不能直接定义一个sales_data的multiset，因为sales_data没有<运算符。但是，可以用compareIsbn函数来定义一个multiset
	bool compareIsbn（const Sales_data & lhs，const Salas_data &rhs）
	{
			return lhs.isbn() <rhs.isbn();
	}

	然后当我们定义此容器类型的对象时，需要提供想要使用的操作的指针。在本例中，我们提供一个指向compareIsbn的指针
		multiset<Sales_data,decltype(compareIsbn)*>  bookstore(compareIsbn)
		用compareIsbn来初始化bookstore对象，这表示当我们向bookstore添加元素时，通过调用compareIsbn来为这些元素排序
		即bookstore中的元素将按他们的ISBN成员的值排序

	key_type  此容器类型的关键字类型
	mapped_type    每个关键字关联的类型；只适用于map
	value_type		对于set。与key_type相同     对于 map，为 pair<const key_type, mapped_type>
	
	由于我们不能改变一个元素的关键字，因此这些 pair的关键字   部分是const的：

	与顺序容器一样，我们使用作用域运算符来提取一个类型的成员，例如， map<string,int>::key_type
	
	只有map类型 才定义了  mapped_type

	当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值得引用。
	
	当时用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素
	
	map <string,size_t> word_count        
	word_count["Anna"] = 1
	由于下标运算符可能插入一个新元素，我们只可以对非const的map使用下标操作
	c.at(k)  访问关键字为 k 的元素，带参数检查；若k不在c中，抛出一个out_of_range异常（而不是添加）
	
	当我们遍历一个multimap或multiset时，保证可以得到序列中所有具有给定关键字的元素
	
	如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器
	
	如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不在需要的那些元素。
	
	int * p  = new (nothrow) int; //如果分配失败，那么new返回一个空指针
	
	接受指针参数的智能指针构造函数是 explicit的。因此我们不能将一个内置指针隐式转换为一个智能指针，必须使用初始化形式来初始化一个智能指针
	shared_ptr<int> p2（new int(1024)）;  
	
	我们必须将shared_ptr显式绑定到一个想要返回的指针上
	shared_ptr<int> clone(int p)
	{
		return shared_ptr<int>(new int(p))
	}
	
	shared_ptr<T> p(q,d)   p接管了内置指针q所指向的对象的所有权。q必须能转换为T*类型。p将使用可调用对象d来代替 delete
	
	get 用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。
	特别是，永远不要用get初始化另一个只能指针或者为另一个智能指针赋值
	
	我们可以用reset来将一个新的指针赋予一个shared_ptr
	p.reset(new int(1024));
	
	reset成员经常与unique一起使用，来控制多个shared_ptr共享的对象。在改变底层对象之前，我们检查自己是否是当前独享仅有的用户
	。如果不是，在改变之前要制作一份新的拷贝
		if（!p.unique()）
		{
			p.reset(new string(*P));
			*p += newval;
		}
	
	当我们创建一个shared_ptr时，可以传递一个（可选的）指向删除器函数的参数
	void f(destination &d)
	{
		connection c = connect(&d)
		shared_ptr<connection> p(&c,end_connecion);
		当f退出时（即使死由于异常退出），connection会被正确关闭
	
	
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	



